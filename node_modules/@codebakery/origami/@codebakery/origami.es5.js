import { Directive, ElementRef, HostListener, Inject, Injectable, Injector, Input, NgModule, NgZone, Optional, Renderer, TemplateRef, VERSION, ViewContainerRef, forwardRef, isDevMode } from '@angular/core';
import { FormsModule, NG_VALUE_ACCESSOR, NgControl, Validators } from '@angular/forms';
import { DOCUMENT, ÉµDomSharedStylesHost } from '@angular/platform-browser';

function getCustomElements() {
    return window.customElements;
}

function getTagName(elementRef) {
    return "<" + (elementRef ? elementRef.nativeElement.tagName.toLowerCase() : 'unknown-element') + ">";
}

// tslint:disable-next-line:ban-types
function getCustomElementClass(elementRef) {
    if (elementRef && elementRef.nativeElement) {
        var klass = getCustomElements().get(elementRef.nativeElement.tagName.toLowerCase());
        if (klass) {
            return klass;
        }
        else {
            console.warn(getTagName(elementRef) + " is not registered"); // tslint:disable-line:no-console
        }
    }
}

function getPolymer() {
    return window.Polymer;
}

var EmitChangesDirective = (function () {
    function EmitChangesDirective(elementRef) {
        this.elementRef = elementRef;
    }
    EmitChangesDirective.prototype.ngOnInit = function () {
        var _this = this;
        var klass = getCustomElementClass(this.elementRef);
        if (klass) {
            var properties_1 = {};
            this.copyKeysFrom(klass.__classProperties, properties_1);
            // Listen for notify properties and Object/Array properties which may issue path changes
            var changeable = Object.keys(properties_1).filter(function (propertyName) {
                var property = properties_1[propertyName];
                return property.notify || property === Object || property.type === Object ||
                    property === Array || property.type === Array;
            });
            changeable.forEach(function (property) {
                var eventName = getPolymer().CaseMap.camelToDashCase(property) + "-changed";
                _this.elementRef.nativeElement.addEventListener(eventName, function (event) {
                    _this.elementRef.nativeElement.dispatchEvent(new CustomEvent(property + "Change", {
                        detail: event.detail
                    }));
                });
            });
        }
    };
    EmitChangesDirective.prototype.copyKeysFrom = function (from, to) {
        var proto = from;
        while (proto !== Object.prototype) {
            Object.keys(proto ||
                /* istanbul ignore next */ {}).forEach(function (key) {
                if (key[0] !== '_') {
                    // Only copy public properties
                    to[key] = from[key];
                }
            });
            proto = Object.getPrototypeOf(proto);
        }
    };
    EmitChangesDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[emitChanges]'
                },] },
    ];
    /** @nocollapse */
    EmitChangesDirective.ctorParameters = function () { return [
        { type: ElementRef, },
    ]; };
    return EmitChangesDirective;
}());

function wrapAndDefineDescriptor(target, propertyKey, hooks) {
    var desc = wrapDescriptor(target, propertyKey, hooks);
    Object.defineProperty(target, propertyKey, desc);
}
function wrapDescriptor(target, propertyKey, hooks) {
    var desc = Object.getOwnPropertyDescriptor(target, propertyKey);
    if (!desc) {
        desc = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(target), propertyKey);
    }
    var properties = new WeakMap();
    return {
        enumerable: desc ? desc.enumerable : true,
        get: function () {
            if (desc && desc.get) {
                return desc.get.apply(this);
            }
            else {
                var props = properties.get(this);
                return props && props[propertyKey];
            }
        },
        set: function (original) {
            var value = original;
            if (!hooks.shouldSet || hooks.shouldSet.apply(this, [value])) {
                if (hooks.beforeSet) {
                    value = hooks.beforeSet.apply(this, [value]);
                }
                var props = properties.get(this);
                if (!props) {
                    props = {};
                    properties.set(this, props);
                }
                var changed = value !== props[propertyKey];
                props[propertyKey] = value;
                if (desc && desc.set) {
                    desc.set.apply(this, [value]);
                }
                if (hooks.afterSet) {
                    hooks.afterSet.apply(this, [changed, value, original]);
                }
            }
        }
    };
}

function PolymerChanges() {
    return function (target, propertyKey) {
        var desc = Object.getOwnPropertyDescriptor(target, propertyKey);
        /* istanbul ignore if */
        if (desc && desc.get && !desc.set) {
            // tslint:disable-next-line:no-console
            console.warn(propertyKey + " is readonly. @PolymerChanges() is not needed");
        }
        return wrapDescriptor(target, propertyKey, {
            shouldSet: function (value) {
                if (value instanceof CustomEvent && value.detail.path) {
                    // Object or Array mutation, we need to tell Angular that things have changed
                    if (this.onPolymerChange) {
                        this.onPolymerChange(propertyKey, value, value.detail);
                    }
                    return false;
                }
                else {
                    return true;
                }
            },
            beforeSet: function (value) {
                return unwrapPolymerEvent(value);
            },
            afterSet: function (changed, _value, original) {
                if (changed && this.onPolymerChange && original instanceof CustomEvent) {
                    this.onPolymerChange(propertyKey, original, original.detail);
                }
            }
        });
    };
}
function unwrapPolymerEvent(value) {
    if (value instanceof CustomEvent) {
        return unwrapPolymerEvent(value.detail.value);
    }
    else {
        return value;
    }
}

var IRON_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(function () { return IronControlDirective; }),
    multi: true
};
var IronControlDirective = (function () {
    function IronControlDirective(elementRef, injector, renderer) {
        this.elementRef = elementRef;
        this.injector = injector;
        this.renderer = renderer;
        this.ironCheckedElement = false;
        this.ironSelectable = false;
        this.ironMultiSelectable = false;
        this.ironValidatable = false;
        this.isWritingValue = false;
        /* istanbul ignore next */
        this.onChange = function (_) { };
        /* istanbul ignore next */
        this.onTouched = function () { };
    }
    IronControlDirective.prototype.ngOnInit = function () {
        var ironFormElement = 'value' in this.elementRef.nativeElement;
        this.ironCheckedElement = 'checked' in this.elementRef.nativeElement;
        this.ironSelector = this.ironSelector || this.elementRef.nativeElement;
        this.ironSelectable = Array.isArray(this.ironSelector.items);
        this.ironMultiSelectable = 'multi' in this.ironSelector;
        this.ironValidatable = typeof this.elementRef.nativeElement.validate === 'function';
        // IronSelector may be a different element, and default changed events do not bubble.
        // Therefore it's important to add listeners to the element itself rather than the host
        this.boundSelectedChanged = this.onSelectedChanged.bind(this);
        this.ironSelector.addEventListener('selected-changed', this.boundSelectedChanged);
        this.ironSelector.addEventListener('selected-values-changed', this.boundSelectedChanged);
        if (!ironFormElement && !this.ironCheckedElement && !this.ironSelectable) {
            // tslint:disable-next-line:no-console
            console.warn(getTagName(this.elementRef) + " does not implement IronFormElementBehavior, " +
                "IronCheckedElementBehavior, or IronSelectableBehavior. If this element wraps an " +
                "element with IronSelectableBehavior, add [ironSelector]=\"elementRef\"");
        }
    };
    IronControlDirective.prototype.ngAfterViewInit = function () {
        var _this = this;
        this.ngControl = this.injector.get(NgControl, null); // tslint:disable-line:no-null-keyword
        /* istanbul ignore else */
        if (this.ngControl) {
            /* istanbul ignore else */
            if (this.ironValidatable) {
                // Custom validators should update native element's validity
                /* istanbul ignore else */
                if (this.ngControl.statusChanges) {
                    this.statusSub = this.ngControl.statusChanges.subscribe(function () {
                        _this.elementRef.nativeElement.invalid = _this.ngControl.dirty && _this.ngControl.invalid;
                    });
                }
                // Native element's validate() will be called whenever Angular forms perform validation
                // checks. The side-effect of this is that <iron-form> is not required. Angular forms will
                // work just fine.
                /* istanbul ignore else */
                if (this.ngControl.control) {
                    this.ngControl.control.setValidators(Validators.compose([
                        this.ngControl.control.validator,
                        function () {
                            if (_this.elementRef.nativeElement.validate()) {
                                return null; // tslint:disable-line:no-null-keyword
                            }
                            else {
                                // IronValidatableBehavior only tells us if something is wrong, not the specifics
                                return {
                                    ironValidatable: true
                                };
                            }
                        }
                    ]));
                }
            }
        }
    };
    IronControlDirective.prototype.ngOnDestroy = function () {
        /* istanbul ignore next */
        if (this.statusSub) {
            this.statusSub.unsubscribe();
        }
        this.ironSelector.removeEventListener('selected-changed', this.boundSelectedChanged);
        this.ironSelector.removeEventListener('selected-values-changed', this.boundSelectedChanged);
    };
    IronControlDirective.prototype.writeValue = function (obj) {
        // When a control is reset, it will write the default value to the control. A Polymer element
        // will also fire a changed event, but we don't need to inform NgControl of this change.
        this.isWritingValue = true;
        if (this.ironCheckedElement) {
            this.renderer.setElementProperty(this.elementRef.nativeElement, 'checked', Boolean(obj));
        }
        else if (this.ironSelectable || this.ironMultiSelectable) {
            if (this.elementRef.nativeElement.multi) {
                this.renderer.setElementProperty(this.ironSelector, 'selectedValues', obj);
            }
            else {
                this.renderer.setElementProperty(this.ironSelector, 'selected', obj);
            }
        }
        else {
            this.renderer.setElementProperty(this.elementRef.nativeElement, 'value', obj);
        }
        this.isWritingValue = false;
    };
    IronControlDirective.prototype.registerOnChange = function (fn) {
        this.onChange = fn;
    };
    IronControlDirective.prototype.registerOnTouched = function (fn) {
        this.onTouched = fn;
    };
    IronControlDirective.prototype.setDisabledState = function (isDisabled) {
        this.renderer.setElementProperty(this.elementRef.nativeElement, 'disabled', isDisabled);
    };
    IronControlDirective.prototype.onInput = function (event) {
        if (!this.isWritingValue) {
            this.onChange(event.target.value);
        }
    };
    IronControlDirective.prototype.onCheckedChanged = function (event) {
        if (!this.isWritingValue) {
            this.onChange(event.detail.value);
        }
    };
    IronControlDirective.prototype.onBlurOrActive = function () {
        this.onTouched();
    };
    IronControlDirective.prototype.onSelectedChanged = function () {
        if (!this.isWritingValue) {
            if (this.ironSelector.multi) {
                this.onChange(this.ironSelector.selectedValues);
            }
            else {
                this.onChange(this.ironSelector.selected);
            }
        }
    };
    IronControlDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[ironControl]',
                    providers: [IRON_CONTROL_VALUE_ACCESSOR]
                },] },
    ];
    /** @nocollapse */
    IronControlDirective.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: Injector, },
        { type: Renderer, },
    ]; };
    IronControlDirective.propDecorators = {
        'ironSelector': [{ type: Input },],
        'onInput': [{ type: HostListener, args: ['value-changed', ['$event'],] },],
        'onCheckedChanged': [{ type: HostListener, args: ['checked-changed', ['$event'],] },],
        'onBlurOrActive': [{ type: HostListener, args: ['blur',] }, { type: HostListener, args: ['iron-activate',] },],
    };
    return IronControlDirective;
}());

var CustomStyleService = (function () {
    function CustomStyleService(dom) {
        this.dom = dom;
    }
    CustomStyleService.prototype.updateCustomStyles = function (nativeEncapsulatedHost) {
        // tslint:disable-next-line:no-console
        console.warn('CustomStyleService is deprecated. Remove calls to updateCustomStyles() and ' +
            'import PolymerModule.forRoot() instead.');
        this.wrapHeadStyles();
        if (nativeEncapsulatedHost && nativeEncapsulatedHost.nativeElement.shadowRoot) {
            this.wrapStyles(nativeEncapsulatedHost.nativeElement.shadowRoot.querySelectorAll('style'));
        }
    };
    CustomStyleService.prototype.wrapHeadStyles = function () {
        this.wrapStyles(this.dom.head.querySelectorAll('head > style'));
    };
    CustomStyleService.prototype.wrapStyles = function (styles) {
        var _this = this;
        Array.from(styles).forEach(function (style) {
            _this.wrapCustomStyle(style);
        });
    };
    CustomStyleService.prototype.wrapCustomStyle = function (styleEl) {
        var parent = styleEl.parentNode;
        var sibling = styleEl.nextSibling;
        parent.removeChild(styleEl);
        var customStyle = this.dom.createElement('custom-style');
        customStyle.appendChild(styleEl);
        if (sibling) {
            parent.insertBefore(customStyle, sibling);
        }
        else {
            parent.appendChild(customStyle);
        }
    };
    CustomStyleService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    CustomStyleService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },
    ]; };
    return CustomStyleService;
}());

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

// First group is incorrect escape backslash, second group is rest of mixin detection
var MIXIN_REGEX = /(\\)(--\w[\w-_]*:\s*{)/g;
var PolymerDomSharedStylesHost = (function (_super) {
    __extends(PolymerDomSharedStylesHost, _super);
    function PolymerDomSharedStylesHost(document) {
        var _this = _super.call(this, document) || this;
        _this.document = document;
        _this.hostNodes = new Set();
        _this.customStyleNodes = new Set();
        _this.hostNodes.add(document.head);
        return _this;
    }
    PolymerDomSharedStylesHost.prototype.addStyles = function (styles) {
        _super.prototype.addStyles.call(this, styles.map(function (style) { return style.replace(MIXIN_REGEX, '$2'); }));
    };
    PolymerDomSharedStylesHost.prototype.addHost = function (hostNode) {
        _super.prototype.addHost.call(this, hostNode);
        this.hostNodes.add(hostNode);
        this.wrapStyleNodes();
    };
    PolymerDomSharedStylesHost.prototype.onStylesAdded = function (additions) {
        _super.prototype.onStylesAdded.call(this, additions);
        this.wrapStyleNodes();
    };
    PolymerDomSharedStylesHost.prototype.removeHost = function (hostNode) {
        _super.prototype.removeHost.call(this, hostNode);
        this.hostNodes.delete(hostNode);
    };
    PolymerDomSharedStylesHost.prototype.wrapStyleNodes = function () {
        var _this = this;
        this.hostNodes.forEach(function (hostNode) {
            Array.from(hostNode.childNodes).forEach(function (childNode) {
                var childEle = childNode;
                if (childEle.tagName === 'STYLE' && !childEle.hasAttribute('scope')) {
                    var customStyleEl = _this.document.createElement('custom-style');
                    hostNode.removeChild(childNode);
                    childEle.setAttribute('is', 'custom-style');
                    customStyleEl.appendChild(childNode);
                    hostNode.appendChild(customStyleEl);
                }
            });
        });
    };
    /** @nocollapse */
    PolymerDomSharedStylesHost.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },
    ]; };
    return PolymerDomSharedStylesHost;
}(ÉµDomSharedStylesHost));

/* istanbul ignore next */
function webcomponentsSupported() {
    // HTML imports
    if (!('import' in document.createElement('link'))) {
        return false;
    }
    // Shadow DOM
    if (!('attachShadow' in Element.prototype && 'getRootNode' in Element.prototype)) {
        return false;
    }
    // Custom elements
    if (!window.customElements) {
        return false;
    }
    // Templates
    if (!('content' in document.createElement('template')) ||
        // Edge has broken fragment cloning which means you cannot clone template.content
        !(document.createDocumentFragment().cloneNode() instanceof DocumentFragment)) {
        return false;
    }
    return true;
}
// webcomponents-lite.js will override Promise. Angular provides its own Promise polyfill, so we
// want to make sure we keep that.
var OriginalPromise = typeof window === 'object' ? window.Promise : {}; // tslint:disable-line:variable-name
var readyPromise;
var priorityPromise;
function webcomponentsReady(priority) {
    // Priority should only be used by Origami. It ensures priority tasks are run before all other
    // tasks (including the Angular app's bootstrap)
    if (!readyPromise) {
        /* istanbul ignore next */
        priorityPromise = new Promise(function (resolve, reject) {
            if (typeof window === 'object' && window.WebComponents) {
                if (window.WebComponents.ready) {
                    window.Promise = OriginalPromise;
                    resolve();
                }
                else {
                    // tslint:disable-next-line:only-arrow-functions
                    document.addEventListener('WebComponentsReady', function onready() {
                        window.Promise = OriginalPromise;
                        resolve();
                        document.removeEventListener('WebComponentsReady', onready);
                    });
                }
            }
            else if (webcomponentsSupported()) {
                resolve();
            }
            else {
                reject(new Error('WebComponent support or polyfills are not present'));
            }
        });
        readyPromise = priorityPromise.then(function () {
            return new Promise(function (resolve) {
                setTimeout(resolve);
            });
        });
    }
    return priority ? priorityPromise : readyPromise;
}

// tslint:disable:no-string-literal
/* istanbul ignore next */
function shimHTMLTemplateAppend() {
    // Even when this enableLegacyTemplate is false, the resulting <template> has childNodes
    // appended to it instead of its #document-fragment
    // https://github.com/angular/angular/issues/15557
    var nativeAppend = HTMLTemplateElement.prototype.appendChild;
    // tslint:disable-next-line:only-arrow-functions
    HTMLTemplateElement.prototype.appendChild = function (childNode) {
        if (this.content) {
            return this.content.appendChild(childNode);
        }
        else {
            return nativeAppend.apply(this, [childNode]);
        }
    };
}
/* istanbul ignore next */
if (typeof HTMLTemplateElement !== 'undefined') {
    shimHTMLTemplateAppend();
}
else {
    webcomponentsReady(true).then(shimHTMLTemplateAppend).catch(function () { });
}
/* istanbul ignore next */
if (VERSION.major === '4' && VERSION.minor < '2' && isDevMode()) {
    // tslint:disable-next-line:no-console
    console.warn('Angular 4.2.0 has fixed enableLegacyTemplate. Origami strongly recommends to ' +
        'update to this version so that <template> elements work across all web components.');
}
var PolymerTemplateDirective = (function () {
    function PolymerTemplateDirective(elementRef, view, templateRef, zone) {
        var _this = this;
        this.zone = zone;
        // enableLegacyTemplate is working since 4.2.0
        if (elementRef.nativeElement.nodeType === Node.COMMENT_NODE) {
            /* istanbul ignore next */
            if (VERSION.major >= '4' && VERSION.minor >= '2') {
                // tslint:disable-next-line:no-console
                console.warn('<ng-template polymer> is deprecated. Use <template> and ' +
                    'enableLegacyTemplate: false');
            }
            var parentNode_1 = view.element.nativeElement.parentNode;
            this.template = document.createElement('template');
            var viewRef = view.createEmbeddedView(templateRef);
            viewRef.rootNodes.forEach(function (rootNode) {
                parentNode_1.removeChild(rootNode);
                _this.template.content.appendChild(rootNode);
            });
            parentNode_1.appendChild(this.template);
            // Detach and re-attach the parent element. This will trigger any template attaching logic
            // that a custom elements needs which Angular skipped when using <ng-template>
            var hostNode = parentNode_1.parentNode;
            hostNode.removeChild(parentNode_1);
            hostNode.appendChild(parentNode_1);
        }
        else {
            this.template = elementRef.nativeElement;
        }
    }
    Object.defineProperty(PolymerTemplateDirective.prototype, "methodHost", {
        set: function (host) {
            // tslint:disable-next-line:no-console
            console.warn('<template polymer [methodHost]="host"> is deprecated. Use ' +
                '<template [polymer]="host"> instead.');
            this.host = host;
        },
        enumerable: true,
        configurable: true
    });
    PolymerTemplateDirective.prototype.ngOnInit = function () {
        var _this = this;
        if (this.host) {
            // Configure host event binding
            this.template['__dataHost'] = this.host;
            // Shim Polymer.TemplateStamp mixin. This allows event bindings in Polymer to be used, such
            // as on-click
            this.host['_addEventListenerToNode'] = function (node, eventName, handler) {
                node.addEventListener(eventName, handler);
            };
            this.host['_removeEventListenerFromNode'] = function (node, eventName, handler) {
                node.removeEventListener(eventName, handler);
            };
            if (this.template._templateInfo) {
                this.onTemplateInfoChange(this.template._templateInfo);
            }
            wrapAndDefineDescriptor(this.template, '_templateInfo', {
                afterSet: function (_changed, templateInfo) {
                    // Micro timing, templateInfo is set to an empty object first before hostProps are added
                    setTimeout(function () { return _this.onTemplateInfoChange(templateInfo); });
                }
            });
        }
    };
    PolymerTemplateDirective.prototype.onTemplateInfoChange = function (templateInfo) {
        var _this = this;
        // Setup host property binding
        if (templateInfo && templateInfo.hostProps) {
            Object.keys(templateInfo.hostProps).forEach(function (hostProp) {
                // Polymer -> Angular
                var eventName = "_host_" + getPolymer().CaseMap.camelToDashCase(hostProp) + "-changed";
                _this.template.addEventListener(eventName, function (e) {
                    _this.zone.run(function () {
                        var value = unwrapPolymerEvent(e);
                        if (_this.host[hostProp] !== value) {
                            _this.host[hostProp] = value;
                        }
                    });
                });
                // Angular -> Polymer
                wrapAndDefineDescriptor(_this.host, hostProp, {
                    beforeSet: function (value) {
                        return unwrapPolymerEvent(value);
                    },
                    afterSet: function (changed, value) {
                        if (changed) {
                            _this.template["_host_" + hostProp] = value;
                        }
                    }
                });
            });
        }
    };
    PolymerTemplateDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'ng-template[polymer], template[polymer]'
                },] },
    ];
    /** @nocollapse */
    PolymerTemplateDirective.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: ViewContainerRef, decorators: [{ type: Optional },] },
        { type: TemplateRef, decorators: [{ type: Optional },] },
        { type: NgZone, },
    ]; };
    PolymerTemplateDirective.propDecorators = {
        'host': [{ type: Input, args: ['polymer',] },],
        'methodHost': [{ type: Input },],
    };
    return PolymerTemplateDirective;
}());

var PolymerModule = (function () {
    function PolymerModule() {
    }
    PolymerModule.forRoot = function () {
        return {
            ngModule: PolymerModule,
            providers: [
                { provide: ÉµDomSharedStylesHost, useClass: PolymerDomSharedStylesHost }
            ]
        };
    };
    PolymerModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        FormsModule
                    ],
                    declarations: [
                        EmitChangesDirective,
                        IronControlDirective,
                        PolymerTemplateDirective
                    ],
                    providers: [
                        CustomStyleService
                    ],
                    exports: [
                        EmitChangesDirective,
                        IronControlDirective,
                        PolymerTemplateDirective
                    ]
                },] },
    ];
    /** @nocollapse */
    PolymerModule.ctorParameters = function () { return []; };
    return PolymerModule;
}());

/**
 * Generated bundle index. Do not edit.
 */

export { EmitChangesDirective, PolymerChanges, unwrapPolymerEvent, IRON_CONTROL_VALUE_ACCESSOR, IronControlDirective, PolymerModule, CustomStyleService, PolymerDomSharedStylesHost, PolymerTemplateDirective, getCustomElements, wrapAndDefineDescriptor, wrapDescriptor, getCustomElementClass, getTagName, getPolymer, webcomponentsSupported, webcomponentsReady };
//# sourceMappingURL=origami.es5.js.map
